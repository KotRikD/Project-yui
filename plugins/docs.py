'''
Данный файл является плагин-примером всех функций Project YUI

Основные вещи:
Есть 3 хранилища для хранения некоторого типа данных:
- Системное (в нём хранятся врапперы, конфиги бота)
- Хранилище плагина (в нём может содержаться информация о пользователях, или каких-то данных.
- Хранилище сообщения (это хранилище которое гуляет между плагинами в нём содержится информация о методах, может использоваться
для передачи какой-то информации между плагинами)

Как вызывать?
- Системное (from common.Store import store)
- Хранилище плагина (plugin.ystore)
- Хранилище сообщения (store в каждом методе)

Конфиг:
Конфиг может изменяться и дописываться как вам угодно, в него можно поместить свои данные, но не забудьте, что надо также
будет добавить эти данные в utils/LoadConfig.py переменная need_values.
Его можно портировать откуда угодно. Вызываем системное хранилище, и вызываем store.config.<Your Value>

Методы и жизненный цикл бота:
Цикл довольно прост:
- Ининциализация плагина
При сообщении:
- Перед сообщением(можно остановить последующие действия)->Попытка вызвать команду->После сообщения(после команды)

Соответсвенно:
on_init(store) Здесь store будет системное хранилище, да-да можно с говнокодить и засунуть системное хранилище в хранилище плагин(Но скажи, ТЫ ДОЛБОЁБ?)
before_command(update,store)
on_command(update, store)
after_command(update, store)

Что хранится в store? Хранилище сообщения
Что хранится в update? Информация о сообщении

Что можно получить из update?
- text
- attachs (Вложения)
- from_id
- peer_id
- is_multichat
- chat_id
- raw_update

Что хранить и вызывать в store?
Хранить можно всё, что угодно. store.<value> = value
Вызывать можно:
- reply() - Ответ на сообщение
- upload_photo() - Загрузка фотографии
- upload_doc() - Загрузка документа
- request() - Вызыв к VK API

Ну вроде всё, давайте приступим к практике:
'''
from common.Plugin import YPlugin # Портируем наш плагин

import common.Logger as Logger # Портируем логгер
'''
Логгер:
Имеет кучу переменных, нам нужно несколько которые часто будем использовать:
- Ylog(msg) - лог фиолетовым цветом YuiLog
- Elog(msg) - лог красным цветом ErrorLog
- Nlog(msg) - лог жёлтым цветом NotifyLog
- Slog(msg) - лог тёмно зелёным цветом SuccessLog

И цвета:
Logger.<color> - цвета можно узнать в common/Logger.py в секции Console colors
и для того что бы написать этим цветом, мы вызываем
Logger.printColored(msg, color)

'''

# Регестрируем instance нашего плагина, в аргументах может быть, что угодно, позже объясню как к этому обращаться
plugin = YPlugin(name="Test")

# Создаём декоратор инициализации
@plugin.on_init()
async def on_init(store):
    group_id = store.config.group_id

    Logger.Nlog(f"Плагин был загружен с group_id = {group_id} и названием {plugin.name}.\n"
                f"Хранилище плагина {plugin.ystore}\n"
                f"Системное хранилище {store}") # Мы заметили очень много весёлого да? Согласен, забавно

    # В данном случае в on_init вызывается СИСТЕМНОЕ ХРАНИЛИЩЕ! А НЕ ХРАНИЛИЩЕ СООБЩЕНИЯ!
    # Если вы хотите отсюда вызвать какой-то метод вам надо обратиться к нему: await store.wrappers.request(method, kwargs)

#Создаём декоратор перед сообщением
@plugin.before_command()
async def before_command(update, store):
    Logger.Nlog(f"Вау, пришло сообщение {update.text} от {update.from_id}")

    #Здесь хранилище будет уже сообщения.
    command = update.command if update.get("command", False) else None
    # Замечу почему так, бот регистрирует команды в определённую ячейку, этот же метод будет вызываться КАЖДОЕ сообщение
    # даже без команды, так что не стоит отсюда что-либо вызывать связанное с этим, также у update есть ещё args (аргументы)
    args = update.args if update.get("args", False) else None

    # Например в течении этого цикла пагинов, мы хотим чтобы перед каждым сообщением бот оставлял что-нибудь.
    store['custom_message'] = "Пользователь, " # Теперь бот будет писать (Пользователь, <msg>)

    # Думаю здесь всё ясно, идём дальше
    return False # False - говорит о том, что надо продолжать исполнение, True - остановит же процесс.

#По поводу команд, нельзя делать одинаковые команды с названиями сначала
#Например если вы создадите две команды
#!!!!!!!!!!!!!!!!!!!!!!!!!!
#yui и yui2 вызовится лишь первая команда, и посчитай аргументами 2, так-что стоит думать об этом заранее.
#!!!!!!!!!!!!!!!!!!!!!!!!!!

#Создаём обработчик команды
#В аргументах, должно быть или одна или несколько команд: "бот" или ["бот", "yui"] (list или tuple)
@plugin.on_command("yui") # говорим, что этому обработчику надо реагировать только на одну команду "yui"
async def on_command(update, store):
    #Смотри, например нам надо, обратиться к вк апи и получить информацию о пользователе, выполняем
    result = await store.request("users.get", user_ids=update.from_id)
    if 'response' in result: #проверяем есть ли ответ от сервера, нету? Произошла ошибка, проверь какой метод ты запрашиваешь.
        first_name = result.response[0]['first_name']
        last_name = result.response[0]['last_name']

        # И отвечаем пользователю
        return await store.reply(f"Спасибо, что написал нам: {first_name} {last_name}")


#Давайте ещё посоздаём команд, которые опишут другие методы
@plugin.on_command("2yui")
async def on_command(update, store):
    # Отлично, мы снова готовы писать команду!
    # Итак давай скажем, что мы хотим проверить беседа ли это?
    if update.is_multichat:
        await store.reply("Вау, это сообщение пришло из беседы.")
    # В остальных случаях будет else

    # А что если мы хотим загрузить какое-нибудь изображение??????
    # Значит, что мы можем предпринять?
    # Выход один, придётся вызывать метод
    photo = await store.upload_photo("example/google-chan.png") # Давай загрузим смущающуюся Google-Chan из папки Example
    # ЗАМЕЧУ, что аргументом может быть bytes, тоесть io.Bytes тоже будет работать с его буффером, который зачастую используется для
    # сохранения из Pillow, и других модулей
    if photo:
        Logger.Slog("Теперь у нас есть изображение на сервере ВК, давайте пока его оставим в покое.")


    # А что если мы хотим загрузить документ???? Казалось бы цель опять не достигаема, но нам на помощь опять приходит метод
    # Всё как с загрузкой фото, только на этот раз загрузим текст из папки, но также можно использовать io.Bytes, bytes и т.д.
    doc = await store.upload_doc("example/super_file.txt", filename="yui_bot_test_ex.txt") # Загрузим его на сервер с именем, yui_bot_test_ex.txt, по умолчанию будет file.png
    if doc:
        Logger.Slog("И снова шок, теперь у нас есть загруженный документ")

    # Так теперь давайте отправлять нашему пользователю, а то заждался наверное пока я тут пишу это.
    attachments = [photo, doc]

    # ИЛИ await store.reply("text", attachment=photo)
    return await store.reply("Спасибо за ожидание, меня вводили в курс дела", attachment=attachments)


'''
Теперь одно из самых важных работы с БД:
Для этого в боте реализованы две БД.
MySQL и PostgresSQL - peewee_async
Redis - asyncio_redis

Для включения надо, зайти в файл конфига и настроить конфигурацию БД.
Для включения БД, надо поставить переменную UseDB -> true
Что бы выбрать какой драйввер использовать, меняем в конфиге DBSettings -> DBDriver (mysql | psql)
Что бы включить Redis, надо поставить переменную UseRedis -> true

Создавать модели peewee, надо в папке db/Models/ , по примеру SimpleModel.py
Что бы эти модели загрузились добавляем from .YourModel import * в db/Models/__init__.py на последней строке!

Окей, ты молодец, ты настроил БД, как теперь к ней обращаться????

Для этого надо вызывать системное хранилище, смотри в самом начале этого файла.
- store.config.db - DB
- store.config.redis - RedisDB

Эти переменные могут быть, только когда БД настроена и включена.
Если ты пишешь бота кому-нибудь, можешь сделать проверки на то, включена ли БД.
if store.config.get("db", False):
    return print("Пожалуйста включите БД")
    
Также с Redis)

А как вызывать модели? from db.Models import <YourModel>, или все модели from db.Models import *
Немало важной утилитой является get_or_none, в db.Models, она может упростить вашу жизнь по запросу и нахождению данных)
Например

from db.Models import get_or_none, MyModel (всё есть в файлах примеров)

user = await get_or_none(MyModel, user_id=update.from_id)
if user:
    print("Пользователь был найден")
    print(user.user_id)
else:
    print("Пользователя не существует")

С редисом, я тут подробно не буду описывать, читаем документации к asyncio_redis.
Давайте напишем пару команд, которые опишут это
'''

from common.Store import store as sysstore
from db.Models import *

@plugin.on_command("dbyuitest")
async def on_command(update, store):
    if sysstore.config.get("db", False): # Проверяем есть ли настроенная БД
        return await store.reply("Пожалуйста, включите БД в настройках бота!")

    user = await get_or_none(MyModel, user_id=update.from_id) # Запрашиваем пользователя
    if not user: # Обидно, нашего пользователя не существует, давайте это исправим
        if not update.args: # В данном случае, модель представляет собой просто строку и пользовательский id
            return await store.reply("А что вы хотите сохранить?") # Просим пользователя написать что-нибудь после команды.

        text = ' '.join(update.args) # Сохраняем это в строку можно конечно и text = update.text[len(update.cmd):].strip()

        user = await store.config.db.get_or_create(MyModel, user_id=update.from_id, string_model=text) # store.config.db - наследуется от peewee_async.Manager, соответсвенно у него есть такой метод) Читаем документацию к библиотеке)

    return await store.reply("Так-с-с-с, я нашла только:\n"
                             f"{user.string_model}") # Теперь когда наш пользователь 100% существует, мы отправляем, то что он сохранил ;D

